package com.tipdm.framework.dmserver.core.task.listener;

import com.tipdm.framework.dmserver.core.task.model.Job;
import com.tipdm.framework.dmserver.core.task.model.Link;
import com.tipdm.framework.dmserver.core.task.schedule.*;
import com.tipdm.framework.dmserver.task.job.WorkFlowJobBean;
import com.tipdm.framework.dmserver.websocket.MessageServer;
import com.tipdm.framework.dmserver.websocket.workflow.Type;
import com.tipdm.framework.dmserver.websocket.workflow.WorkFlowMessage;
import org.apache.commons.lang3.ThreadUtils;
import org.quartz.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.CollectionUtils;

import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

//import org.redisson.core.RMapCache;

/**
 * Created by TipDM on 2017/1/11.
 * E-mail:devp@tipdm.com
 */
@SuppressWarnings("all")
public class WorkFlowJobListener implements JobListener {

    private final Logger logger = LoggerFactory.getLogger(this.getClass());

    private String listenerName;

    private final static String LISTENER_NAME = "workFlowJobListener";

//    private WorkFlowWebSocketHandler workFlowWebSocketHandler = SpringUtils.getBean("workFlowWebSocketHandler", WorkFlowWebSocketHandler.class);
//    private MessageServer messageServer = SpringUtils.getBean("messageServer", MessageServer.class);

    public WorkFlowJobListener(String listenerName){
        this.listenerName = listenerName;
    }

    @Override
    public String getName() {
//        return LISTENER_NAME;
        return this.listenerName;
    }

    /**
     * job执行之前
     * @param context
     */
    @Override
    public void jobToBeExecuted(JobExecutionContext context) {

        logger.info("jobToBeExecuted...");
        JobDataMap jobDataMap = context.getJobDetail().getJobDataMap();
        String jobId = jobDataMap.getString("jobId");
        String workFlowId = jobDataMap.getString("workFlowId");
        while (true){
            Optional<Thread> optional = ThreadUtils.findThreadsByName(JobCallback.JOB_CALLBACK_PREFIX + workFlowId, WorkFlowScheduler.jobCallbackGroup).stream().findFirst();
            if(!optional.isPresent()){
                break;
            }
            JobCallback jobCallback = (JobCallback) optional.get();
            if(jobCallback.jobIsReady(jobId)){
                break;
            }
            try {
                logger.info("job【{}.{}】 still running...", workFlowId, jobId);
                Thread.sleep(1000 * 5);
            } catch (InterruptedException e) {
                break;
            }
        }
    }

    /**
     * 当TriggerListener中的vetoJobExecution方法返回true时,执行这个方法.
     * 这个方法如果被执行，jobToBeExecuted和jobWasExecuted就不会执行
     * @param context
     */
    @Override
    public void jobExecutionVetoed(JobExecutionContext context) {

        logger.error("job '" +context.getJobDetail().getKey().getName()+ "' will be cancel");
    }

    /**
     * 任务执行完成后执行,jobException如果不为空则说明任务在执行过程中出现了异常
     * @param context
     * @param e
     */
    @Override
    public void jobWasExecuted(JobExecutionContext context, JobExecutionException e) {

        logger.info("jobWasExecuted...");
        JobDataMap jobDataMap = context.getJobDetail().getJobDataMap();

        String jobId = jobDataMap.getString("jobId");
        String workFlowId = jobDataMap.getString("workFlowId");
        Optional<Thread> optional = ThreadUtils.findThreadsByName(JobCallback.JOB_CALLBACK_PREFIX + workFlowId, WorkFlowScheduler.jobCallbackGroup).stream().findFirst();
        if(!optional.isPresent()){
            return;
        }
        JobCallback jobCallback = (JobCallback) optional.get();
        WorkFlow workFlow = jobCallback.getWorkFlow();
        Job job = workFlow.getJob(jobId);
        logger.info("jobId: {}, workFlowId: {}", job.getJobId(), workFlowId);
        WorkFlowMessage message;
        if(null == e) {
            jobCallback.updateJobState(jobId, JobState.COMPLETE);
            //推送状态
            message = new WorkFlowMessage();
            message.setNodeId(job.getJobId());
            message.setState(JobState.COMPLETE);
//            workFlowWebSocketHandler.broadcast(flow.getWorkFlowId(), JSON.toJSONString(message));
            MessageServer.notify(workFlowId, message);
            if(workFlow.getState().compareTo(WorkFlowState.RUNNING) == 0) {
                //如果当前流程的运行模型不是运行到此节点且有下级Job
                if (!job.isEndedNode() && !CollectionUtils.isEmpty(job.getAfterJobs())) {
                    //更改连接线的状态
                    changeLinkState(job.getJobId(), workFlow);
                    //执行后面的job
                    scheduleAfterJobs(context, workFlow, job.getAfterJobs(), jobCallback);
                }
            }
            //下级节点添加到runningjob集合后再移除当前job
//            workFlow.removeJobFromRunningJobs(job);
            jobCallback.removeJob(jobId);
        } else {
            e.setUnscheduleAllTriggers(true);
            jobCallback.removeJob(jobId);
            jobCallback.updateJobState(jobId, JobState.ERROR);
            //推送状态
            message = new WorkFlowMessage();
            message.setNodeId(job.getJobId());
            message.setState(JobState.ERROR);

//            workFlowWebSocketHandler.broadcast(flow.getWorkFlowId(), JSON.toJSONString(message));
            MessageServer.notify(workFlowId, message);
            //终止下级节点
            if(!CollectionUtils.isEmpty(job.getAfterJobs())){
                for(String after : job.getAfterJobs()){
                    if(jobCallback.removeJob(after)) {
                        jobCallback.updateJobState(after, JobState.ABORT);
                    }
                }
//                job.getAfterJobs().stream().forEach(x -> {
//                    if(tmpFlow.getRunningJobs().contains(x.getJobId())){
//                        com.tipdm.framework.dmserver.core.task.model.Job after = tmpFlow.getJob(x.getJobId());
//                        after.getState().set(JobState.ABORT);
//                        tmpFlow.removeJobFromRunningJobs(x);
//                    }
//                });
            }
        }
//        mapCache.replace("workFlow", workFlow);
    }

    /**
     * 执行后面的job
     * @param context
     * @param workFlow
     * @param afterJobs
     */
    protected void scheduleAfterJobs(JobExecutionContext context, WorkFlow workFlow, List<String> afterJobs, JobCallback jobCallback) {

        for(int i = 1; i <= afterJobs.size(); i++){
            scheduleJob(context, workFlow, workFlow.getJob(afterJobs.get(i-1)), jobCallback);
        }
    }

    /**
     * 变更连接线的状态
     * @param jobId
     * @param workFlow
     */
    protected void changeLinkState(String jobId, WorkFlow workFlow){

        Set<String> links = workFlow.getLinks().stream().filter(x -> x.getSource().equals(jobId)).map(Link::getId).collect(Collectors.toSet());

        for(String link : links){
            WorkFlowMessage message = new WorkFlowMessage();
            message.setNodeId(link);
            message.setState(JobState.RUNNING);
            message.setType(Type.LINK);

//            workFlowWebSocketHandler.broadcast(workFlow.getWorkFlowId(), JSON.toJSONString(message));
            MessageServer.notify(workFlow.getId(), message);
        }
    }

    protected void scheduleJob(JobExecutionContext context, WorkFlow workFlow, com.tipdm.framework.dmserver.core.task.model.Job job, JobCallback jobCallback) {

        JobKey jobKey = new JobKey(job.getJobId(), job.getJobGroup());
        Scheduler scheduler = context.getScheduler();
        try {
            if(scheduler.checkExists(jobKey)){
                return;
            }
        } catch (SchedulerException e) {
            logger.error("job name " + job.getJobId() + " execute error", e);
        }
        TriggerKey triggerKey = TriggerKey.triggerKey(job.getJobId(), job.getJobGroup());
        Trigger trigger = WorkFlowScheduler.newTrigger(triggerKey);
        JobDetail jobDetail = JobBuilder.newJob(WorkFlowJobBean.class).withIdentity(jobKey).build();
        jobDetail.getJobDataMap().put("jobId", job.getJobId());
        jobDetail.getJobDataMap().put("workFlowId", workFlow.getId());

        try {
            scheduler.scheduleJob(jobDetail, trigger);
//            workFlow.addRunningJob(job);
            jobCallback.addJob(job.getJobId());
        } catch (SchedulerException ex) {
            logger.error("error chaining Job " + job.getJobName(), ex);
        }
    }
}
