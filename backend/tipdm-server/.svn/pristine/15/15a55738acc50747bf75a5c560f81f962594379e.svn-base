package com.tipdm.framework.dmserver.core.task.listener;

import com.alibaba.fastjson.JSON;
import com.tipdm.framework.common.utils.SpringUtils;
import com.tipdm.framework.dmserver.core.task.schedule.TaskScheduler;
import com.tipdm.framework.dmserver.utils.RedissonUtils;
import com.tipdm.framework.model.dmserver.DependentMode;
import com.tipdm.framework.model.dmserver.Task;
import org.quartz.*;
import org.redisson.api.RCountDownLatch;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.concurrent.TimeUnit;

public class TaskJobListener implements JobListener {

    private final Logger logger = LoggerFactory.getLogger(this.getClass());

    public static String DEFAULT_NAME = "TipDM-Task-Group";

    private String listenerName;

    private TaskScheduler taskScheduler = SpringUtils.getBean("taskScheduler", TaskScheduler.class);

    public TaskJobListener(){
        this.listenerName = DEFAULT_NAME;
    }

    public TaskJobListener(String listenerName) {
        this.listenerName = listenerName;
    }

    @Override
    public String getName() {
        return this.listenerName;
    }


    @Override
    public void jobToBeExecuted(JobExecutionContext context) {
        JobDataMap jobDataMap = context.getJobDetail().getJobDataMap();
        Task task = null;
        try {
            task = (Task) jobDataMap.get("task");
        }catch (ClassCastException ex) {
            task = JSON.parseObject(jobDataMap.getString("task"), Task.class);
        }
        String accessToken = jobDataMap.getString("accessToken");

        //如果当前任务有前置任务
        if(task.getHasDepend() && task.getDependentTaskId() != null && DependentMode.BEFORE == task.getDependentMode()){
            logger.debug("检测到当前任务包含前置任务，需要等待前置任务执行后才能继续");
            Task beforeTask = taskScheduler.getTask(task.getDependentTaskId());
            if(beforeTask != null) {
                try {
                    beforeTask.setAbortAfterFinished(true);
                    String jobName = TriggerKey.createUniqueName(beforeTask.getTaskGroup());
                    taskScheduler.schedule(accessToken, jobName, beforeTask, DateBuilder.nextGivenSecondDate(null, 1));
                    logger.debug("before task jobName: {}", jobName);
                    RCountDownLatch countDownLatch = RedissonUtils.getRCountDownLatch(jobName);
                    countDownLatch.trySetCount(1);
                    countDownLatch.await(120, TimeUnit.MINUTES);
                    logger.debug("continue...");
                } catch (SchedulerException e) {
                    e.printStackTrace();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }


    @Override
    public void jobExecutionVetoed(JobExecutionContext context) {

    }

    @Override
    public void jobWasExecuted(JobExecutionContext context, JobExecutionException e) {

        JobDataMap jobDataMap = context.getJobDetail().getJobDataMap();
        JobKey jobKey = context.getJobDetail().getKey();
        Task task = null;
        try {
            task = (Task) jobDataMap.get("task");
        }catch (ClassCastException ex) {
            task = JSON.parseObject(jobDataMap.getString("task"), Task.class);
        }
        String accessToken = jobDataMap.getString("accessToken");
        try {
            logger.info("jobName: {}", jobKey.getName());

            RCountDownLatch countDownLatch = RedissonUtils.getRCountDownLatch(jobKey.getName());
            countDownLatch.countDown();
        }catch (Exception ex){
            logger.warn("call RCountDownLatch.countDown failed, cause: {}", ex.getMessage());
        }
        if(null == e) {
            if (task.getHasDepend() && !task.getAbortAfterFinished() && task.getDependentTaskId() != null && DependentMode.AFTER == task.getDependentMode()) {
                Task afterTask = taskScheduler.getTask(task.getDependentTaskId());
                if (afterTask != null) {
                    try {
                        afterTask.setAbortAfterFinished(true);
                        String jobName = TriggerKey.createUniqueName(afterTask.getTaskGroup());
                        taskScheduler.schedule(accessToken, jobName, afterTask, DateBuilder.nextGivenSecondDate(null, 1));
                    } catch (SchedulerException ex) {
                        ex.printStackTrace();
                    }
                }
            }
        }
    }
}
