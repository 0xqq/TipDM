package com.tipdm.framework.dmserver.core.task.schedule;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONPath;
import com.github.dexecutor.core.task.*;
import com.jayway.jsonpath.JsonPath;
import com.tipdm.framework.common.utils.DateKit;
import com.tipdm.framework.common.utils.PropertiesUtil;
import com.tipdm.framework.common.utils.RedisUtils;
import com.tipdm.framework.common.utils.SpringUtils;
import com.tipdm.framework.dmserver.core.task.model.IO;
import com.tipdm.framework.dmserver.core.task.model.Job;
import com.tipdm.framework.dmserver.core.task.model.Link;
import com.tipdm.framework.dmserver.core.task.model.Node;
import com.tipdm.framework.dmserver.mse.ModelUtil;
import com.tipdm.framework.dmserver.task.job.WorkFlowJobBean;
import com.tipdm.framework.dmserver.utils.CommonUtils;
import com.tipdm.framework.dmserver.utils.Constants;
import com.tipdm.framework.dmserver.utils.RedissonUtils;
import com.tipdm.framework.model.dmserver.Component;
import com.tipdm.framework.model.dmserver.ComponentIO;
import com.tipdm.framework.model.dmserver.DataTable;
import com.tipdm.framework.service.dmserver.ComponentService;
import com.tipdm.framework.service.dmserver.DataTableService;
import org.apache.commons.lang3.math.NumberUtils;
import org.quartz.*;
import org.redisson.api.RAtomicLong;
import org.redisson.api.RCountDownLatch;
import org.redisson.api.RMapCache;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Created by zhoulong on 2019/4/26.
 */
public class JobProvider implements TaskProvider<String, Boolean> {

    private final static Logger LOG = LoggerFactory.getLogger(JobProvider.class);

    private static DataTableService tableService = SpringUtils.getBean("tableService", DataTableService.class);

    private static ComponentService componentService = SpringUtils.getBean("componentService", ComponentService.class);

    private Scheduler scheduler;

    private Map<String, Job> jobMap;

    private WorkFlow workFlow;

    private AtomicBoolean abort;

    private String accessToken;

    private static Long expiredSeconds;

    public JobProvider(WorkFlow workFlow, Scheduler scheduler, AtomicBoolean abort, String accessToken){
        this.scheduler = scheduler;
        this.workFlow = workFlow;
        this.jobMap = workFlow.getJobMap();
        this.abort = abort;
        this.accessToken = accessToken;
    }

    static {
        expiredSeconds = Long.parseLong(PropertiesUtil.getValue("sysconfig/redis.properties", "redis.tableExpired.seconds", "604800"));
    }

    @Override
    public Task<String, Boolean> provideTask(String jobId) {

        return new Task<String, Boolean>() {
            @Override
            public Boolean execute() {
                Job job = jobMap.get(jobId);
                if(job == null){
                    throw new TaskExecutionException("can not found job with id:" + jobId);
                }
                if(abort.get()){
                    throw new TaskExecutionException("abort job with id:" + jobId);
                }

                try {
                    initParameters(job);
                    scheduleJob(job);
                } catch (SchedulerException e) {
                    throw new TaskExecutionException(e.getMessage());
                }
                RMapCache<String, Map<String, Object>> tracker = RedissonUtils.getRMapCache(Constants.WS_TRACKER);
                //初始化闭锁，闭锁会在任务执行完成后释放
                RCountDownLatch countDownLatch = RedissonUtils.getRCountDownLatch(job.getFullJobId());
                countDownLatch.trySetCount(1);
                try {
                    //超过60分钟后自动释放
                    countDownLatch.await(60, TimeUnit.MINUTES);
                } catch (InterruptedException e) {
                    tracker.remove(jobId);
                    throw new TaskExecutionException(e.getMessage());
                }

                job = (Job)tracker.get(jobId).get("job");
                tracker.remove(jobId);
                if(State.ERROR.equals(job.getState())){
                    throw new TaskExecutionException("Job运行错误，id:" + jobId);
                }
                //执行方式运行到此节点则不往后执行
                return !job.isEndedNode();
            }

            @Override
            public boolean shouldExecute(ExecutionResults<String, Boolean> parentResults) {
                Boolean allowBeExecute = Boolean.TRUE;
                for(ExecutionResult<String, Boolean> res : parentResults.getAll()){
                    if(!res.getResult()){
                        allowBeExecute = Boolean.FALSE;
                        break;
                    }
                }

                return allowBeExecute;
            }
        };
    }

    @SuppressWarnings("all")
    private void initParameters(Job job){
        Component component = new Component();
        component.setCreatorName(workFlow.getCreator());

        Node node = workFlow.getNodes().stream().filter(x -> x.getId().equals(job.getJobId())).findFirst().get();
        Component serverComponent = componentService.findOne(node.getServerId());
        BeanUtils.copyProperties(node, component, new String[]{"inputs", "outputs"});
        component.setClientId(Long.parseLong(node.getId()));
        if(null != serverComponent) {
            component.setId(node.getServerId());
            component.setEnabled(serverComponent.getEnabled());
            component.setScript(serverComponent.getScript());
            component.setExtra(serverComponent.getExtra());
        }

        for(IO io : node.getInputs()){
            ComponentIO componentIO = new ComponentIO();
            componentIO.setType(ComponentIO.IOType.INPUT);
            componentIO.setModel(io.getIsModel());
            Optional<Link> optional = workFlow.getLinks().stream().filter(x -> x.getInputPortId().equals(io.getId())).findFirst();
            if(optional.isPresent()) {
                Link tmpLink = optional.get();
                Node tmpNode = workFlow.getNodes().stream().filter(x -> x.getId().equals(tmpLink.getSource())).findFirst().get();
                String tempTable = tmpNode.getOutputs().stream().filter(x -> x.getId().equals(tmpLink.getOutputPortId())).findFirst().get().getValue();

                componentIO.setNodeClientId(io.getId());
                if("model".equals(io.getKey())){
                    componentIO.setTempTable(tempTable);
                } else {
                    if (NumberUtils.isDigits(tempTable)) {
                        DataTable userTable = tableService.findOne(Long.parseLong(tempTable));
                        if(null != userTable) {
                            componentIO.setTempTable(userTable.getTableName());
                        }
                    } else {
                        componentIO.setTempTable("\"" + tempTable + "\"");
                    }
                }
                componentIO.setKey(io.getKey());
                component.getInputs().add(componentIO);
            }
        }

        for(IO io : node.getOutputs()){
            ComponentIO componentIO = new ComponentIO();
            componentIO.setType(ComponentIO.IOType.OUTPUT);
            componentIO.setCanPreview(io.getCanPreview());
            componentIO.setModel(io.getIsModel());
            componentIO.setNodeClientId(io.getId());
            String tempTable = io.getValue();
            if("model".equals(io.getKey())){
                componentIO.setTempTable(tempTable);
            } else {
                //数据源
                if (NumberUtils.isDigits(tempTable)) {
                    DataTable userTable = tableService.findOne(Long.parseLong(tempTable));
                    if(null != userTable) {
                        componentIO.setTempTable(userTable.getTableName());
                    }
                } else {
                    //临时表
                    componentIO.setTempTable(tempTable);
                    RedisUtils.set("@pg:"+tempTable, null, expiredSeconds);
                }
            }
            componentIO.setKey(io.getKey());
            component.getOutputs().add(componentIO);
        }

        job.getAttachment().put("component", component);

        RMapCache<String, Map<String, Object>> tracker = RedissonUtils.getRMapCache(Constants.WS_TRACKER);
        Map<String, Object> data = new HashMap<>();
        data.put("accessToken", accessToken);
        data.put("job", job);
        data.put("node", node);
        data.put("workFlowId", workFlow.getId());
        tracker.put(job.getJobId(), data);
    }

    private void scheduleJob(Job job) throws SchedulerException {
        if (null == job) {
            return;
        }

        TriggerKey triggerKey = TriggerKey.triggerKey(job.getJobId(), job.getJobGroup());
        Trigger trigger = newTrigger(triggerKey);
        JobKey jobKey = new JobKey(job.getJobId(), job.getJobGroup());
        JobDetail jobDetail = JobBuilder.newJob(WorkFlowJobBean.class).withIdentity(jobKey).build();
        jobDetail.getJobDataMap().put("job", JSON.toJSONString(job));
        jobDetail.getJobDataMap().put("accessToken", accessToken);
        try {
            Date date = scheduler.scheduleJob(jobDetail, trigger);
            LOG.info("jobName: {} triggerKey: {} date: {}", jobDetail.getKey().getName(), trigger.getKey().getName(),
                    DateKit.convert2Str("yyyy-MM-dd HH:mm:ss", date));
        } catch (SchedulerException e) {
            LOG.error("节点加入调度失败，错误信息: {}", e.getMessage());
            throw e;
        }
    }

    public Trigger newTrigger(TriggerKey triggerKey) {
        Date startTime = DateBuilder.nextGivenSecondDate(null, 1);//延迟一秒钟执行
        LOG.info("job will execute at: {}", DateKit.convert2Str("yyyy-MM-dd HH:mm:ss", startTime));
        SimpleTrigger trigger = TriggerBuilder.newTrigger()
                .withIdentity(triggerKey)
                .startAt(startTime)
                .withSchedule(
                        SimpleScheduleBuilder.simpleSchedule()
                                .withMisfireHandlingInstructionFireNow()//任务补偿策略：错过执行时间后立即执行
                                .withIntervalInSeconds(0)
                                .withRepeatCount(0))//不重复执行
                .build();
        return trigger;
    }
}
