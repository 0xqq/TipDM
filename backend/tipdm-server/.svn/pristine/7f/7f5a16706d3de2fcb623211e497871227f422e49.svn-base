package com.tipdm.framework.dmserver.task.job;

import com.tipdm.framework.common.utils.PropertiesUtil;
import com.tipdm.framework.dmserver.core.algo.IAlgorithm;
import com.tipdm.framework.dmserver.core.task.model.Job;
import com.tipdm.framework.dmserver.core.task.schedule.JobCallback;
import com.tipdm.framework.dmserver.core.task.schedule.JobState;
import com.tipdm.framework.dmserver.core.task.schedule.WorkFlow;
import com.tipdm.framework.dmserver.core.task.schedule.WorkFlowScheduler;
import com.tipdm.framework.dmserver.websocket.MessageServer;
import com.tipdm.framework.dmserver.websocket.workflow.WorkFlowMessage;
import com.tipdm.framework.model.dmserver.Component;
import com.tipdm.framework.service.dmserver.ComponentService;
import org.apache.commons.lang3.ThreadUtils;
import org.quartz.JobDataMap;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.quartz.QuartzJobBean;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.Optional;

/**
 * @author zhoulong E-mail:devp@tipdm.com
 * @version 创建时间：2016年11月7日 下午2:25:17 类说明
 */
//@PersistJobDataAfterExecution
//@DisallowConcurrentExecution
public class WorkFlowJobBean extends QuartzJobBean {

    private final Logger logger = LoggerFactory.getLogger(this.getClass());

    @Autowired
    private ComponentService componentService;

    public void executeInternal(JobExecutionContext context) throws JobExecutionException {

        try {
            JobDataMap jobDataMap = context.getJobDetail().getJobDataMap();
            String jobId = jobDataMap.getString("jobId");
            String workFlowId = jobDataMap.getString("workFlowId");
            Optional<Thread> optional = ThreadUtils.findThreadsByName(JobCallback.JOB_CALLBACK_PREFIX + workFlowId, WorkFlowScheduler.jobCallbackGroup).stream().findFirst();
            if(!optional.isPresent()){
                return;
            }
            JobCallback jobCallback = (JobCallback) optional.get();
            WorkFlow workFlow = jobCallback.getWorkFlow();
            Job job = workFlow.getJob(jobId);
            Component component = (Component) job.getAttachment().get("component");
            truncateLog(component);
            if(JobState.ABORT.compareTo(job.getState()) == 0){
                String errorMessage = "上级节点运行出错，算法已被终止";
                logger.error(errorMessage);
                throw new JobExecutionException(errorMessage);
            }
            Class clazz;
            try {
                clazz = Class.forName(job.getTargetClazz());
            }catch (ClassNotFoundException ex){
                clazz = Class.forName("com.tipdm.framework.dmserver.core.algo.unparallel.CommonAlgorithm");
            }
            IAlgorithm algorithm = (IAlgorithm) clazz.newInstance();
            if (!component.getEnabled()) {
                throw new IllegalAccessException("组件初始化失败，错误信息：当前组件已被管理员禁用");
            }
            component.setCreatorName(workFlow.getCreator());
            component.setWorkFlow(workFlow);
            //更新状态并推送到前端
            jobCallback.updateJobState(jobId, JobState.RUNNING);
            WorkFlowMessage message = new WorkFlowMessage();
            message.setNodeId(jobId);
            message.setState(JobState.RUNNING);
            MessageServer.notify(workFlowId, message);
            logger.info("job '" +context.getJobDetail().getKey().getName()+ "' will be execute");
            algorithm.run(component);
        } catch (Exception e) {
            throw new JobExecutionException(e);
        }
    }

    @SuppressWarnings("all")
    private void truncateLog(Component component) {
        String id = component.getClientId().toString();
        String log_home = PropertiesUtil.getValue("sysconfig/system.properties", "LOG_HOME");
        try {
            PrintWriter writer = new PrintWriter(new File(log_home + "/" + id + ".log"));
            writer.print("");
            writer.flush();
            writer.close();
        } catch (FileNotFoundException e) {
            logger.error("FileNotFoundException: {}", e);
        }
        MDC.put("component", id);
    }
}
