package com.tipdm.framework.dmserver.core.algo.unparallel.listener;

import com.alibaba.fastjson.JSON;
import com.jayway.jsonpath.JsonPath;
import com.tipdm.framework.common.utils.RedisUtils;
import com.tipdm.framework.dmserver.core.algo.unparallel.executor.ExecutorContext;
import com.tipdm.framework.dmserver.exception.AlgorithmException;
import com.tipdm.framework.dmserver.mse.ModelUtil;
import com.tipdm.framework.dmserver.pyserve.PySession;
import com.tipdm.framework.dmserver.utils.Constants;
import com.tipdm.framework.dmserver.websocket.MessageServer;
import com.tipdm.framework.dmserver.websocket.workflow.ModelMessage;
import com.tipdm.framework.model.dmserver.Component;
import com.tipdm.framework.model.dmserver.ComponentIO;
import com.tipdm.framework.model.dmserver.Model;
import org.dmg.pmml.PMML;
import org.jpmml.evaluator.ModelEvaluator;
import org.jpmml.evaluator.ModelEvaluatorFactory;
import org.jpmml.model.MetroJAXBUtil;
import org.jpmml.sklearn.ClassDictUtil;
import org.jpmml.sklearn.PickleUtil;
import org.jpmml.sklearn.Storage;
import org.openscoring.common.Field;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import sklearn.Estimator;
import sklearn.pipeline.Pipeline;
import sklearn2pmml.pipeline.PMMLPipeline;

import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Created by zhoulong on 2017/6/21.
 * E-mail:zhoulong8513@gmail.com
 */
@SuppressWarnings("all")
public class PyAlgorithmListener implements AlgorithmListener {

    private final Logger logger = LoggerFactory.getLogger(PyAlgorithmListener.class);

    @Override
    public void init(ExecutorContext executorContext) throws AlgorithmException {


    }

    @Override
    public void wasExecuted(ExecutorContext executorContext, AlgorithmException ex) {

        //接收算法报告 & 保存模型
        if (null == ex) {
            PySession session = (PySession) executorContext.getSession();
            Component component = executorContext.getComponent();
            //接收报告
            receiveReport(session, component);

            //保存模型
            saveModel(session, component);
        }
    }

    void receiveReport(PySession session, Component component) {

    }

    void saveModel(PySession session, Component component) {
        File file = null;
        try {
            Map<String, String> params = component.getParameters();
            if (!params.containsKey("features")) {
                logger.warn("参数缺失，参数名：{}", "features");
                return;
            }

            logger.info("检测算法是否有模型输出");
            Optional<ComponentIO> optional = component.getOutputs().stream().filter(x -> "model".equals(x.getKey())).findFirst();
            if (!optional.isPresent()) {
                logger.info("未能检测到模型相关配置");
                return;
            }

            logger.info("开始进行模型序列化操作");
            ComponentIO io = optional.get();
            Long clientId = component.getClientId();
            Model model = new Model();
            model.setCreatorName(component.getCreatorName());
            model.setModelName(component.getName());
            model.setReportFile(clientId + ".html");

            String json = component.getWorkFlow().getOriginalJSON();
            //将输出点的ID作为模型文件名
            String modelDir = RedisUtils.get(Constants.MODEL_DIR, String.class);
            file = new File(modelDir, io.getTempTable());

            net.minidev.json.JSONArray features = JsonPath.parse(json).read("$.nodes[?(@.id=='" + clientId + "')].tabs..featuresItems[?(@.name in [" + params.remove("features") + "])]");
            net.minidev.json.JSONArray target = JsonPath.parse(json).read("$.nodes[?(@.id=='" + clientId + "')].tabs..featuresItems[?(@.name in [" + params.remove("label") + "])]");
            List<Field> featureList = ModelUtil.decodeValues(features);
            List<Field> targetList = ModelUtil.decodeValues(target);

            model.setFeatures(JSON.toJSONString(featureList));
            model.setTarget(JSON.toJSONString(targetList));
            featureList.addAll(targetList);
            model.setOutputs(JSON.toJSONString(featureList));
            model.setModelPath(file.getName());
            model.setNodeId(io.getTempTable());
            //保存建模节点的ID，供预测环节获取预测脚本
            model.setSourceId(component.getId());
            //如果模型支持导出成PMML
            if (component.getSupportPMML()) {

                Object object;

                try (Storage storage = PickleUtil.createStorage(file)) {
                    logger.info("Parsing PKL..");

                    long start = System.currentTimeMillis();
                    object = PickleUtil.unpickle(storage);
                    long end = System.currentTimeMillis();

                    logger.info("Parsed PKL in {} ms.", (end - start));
                } catch (Exception e) {
                    logger.error("Failed to parse PKL", e);

                    throw e;
                }

                if (!(object instanceof PMMLPipeline)) {

                    // Create a single- or multi-step PMMLPipeline from a Pipeline
                    if (object instanceof Pipeline) {
                        Pipeline pipeline = (Pipeline) object;
                        object = new PMMLPipeline().setSteps((List) pipeline.getSteps());
                    } else

                        // Create a single-step PMMLPipeline from an Estimator
                        if (object instanceof Estimator) {
                            Estimator estimator = (Estimator) object;

                            object = new PMMLPipeline().setSteps(Collections.singletonList(new Object[]{"estimator", estimator}));
                        } else

                        {
                            throw new IllegalArgumentException("The object (" + ClassDictUtil.formatClass(object) + ") is not a PMMLPipeline");
                        }
                }

                PMMLPipeline pipeline = (PMMLPipeline) object;

                PMML pmml;

                try {
                    logger.info("Converting..");

                    long begin = System.currentTimeMillis();
                    pmml = pipeline.encodePMML();
                    long end = System.currentTimeMillis();

                    logger.info("Converted in {} ms.", (end - begin));
                } catch (Exception e) {
                    logger.error("Failed to convert", e);

                    throw e;
                }

                File pmmlFile = new File(modelDir, io.getTempTable() + ".pmml");
                try (OutputStream os = new FileOutputStream(pmmlFile)) {
                    logger.info("Marshalling PMML..");

                    long start = System.currentTimeMillis();
                    MetroJAXBUtil.marshalPMML(pmml, os);
                    long end = System.currentTimeMillis();
                    logger.info("Marshalled PMML in {} ms.", (end - start));

                    //override model path
                    model.setModelPath(pmmlFile.getName());

                    ModelEvaluatorFactory modelEvaluatorFactory = ModelEvaluatorFactory.newInstance();
                    ModelEvaluator<?> modelEvaluator = modelEvaluatorFactory.newModelEvaluator(pmml);
                    Map<String, List<Field>> schema = ModelUtil.encodeSchema(modelEvaluator);

                    model.setFeatures(JSON.toJSONString(schema.get("activeFields")));
                    model.setTarget(JSON.toJSONString(schema.get("targetFields")));
                    model.setOutputs(JSON.toJSONString(schema.get("outputFields")));
                } catch (Exception e) {
                    logger.error("Failed to marshal PMML", e);

                    throw e;
                }
            }

            RedisUtils.putToMap(Constants.UN_SAVED_MODEL, io.getTempTable(), model, 72L);
            ModelMessage message = new ModelMessage();
            message.setModelName(model.getModelName());
            message.setNodeId(io.getTempTable());
            message.setWorkFlowId(component.getWorkFlow().getId());

            //推送到客户端未保存模型列表
//            workFlowWebSocketHandler.broadcast(component.getWorkFlow().getWorkFlowId(), JSON.toJSONString(message));
            MessageServer.notify(component.getWorkFlow().getId(), message);

        } catch (Exception e) {
            logger.error("保存算法模型出错，错误信息: {}", e.getMessage());
            if (file != null) {
                file.delete();
            }
        }
    }
}
