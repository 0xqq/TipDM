package com.tipdm.framework.dmserver.websocket;

import com.alibaba.fastjson.JSON;
import com.tipdm.framework.dmserver.websocket.workflow.Message;
import io.socket.client.IO;
import io.socket.client.Socket;
import io.socket.emitter.Emitter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

/**
 * Created by zhoulong on 2018/1/13.
 * E-mail:zhoulong8513@gmail.com
 */
public class MessageServer {

    private final static Logger LOG = LoggerFactory.getLogger(MessageServer.class);

    private String host = "localhost";//服务器主机IP

    private int port = 9020;//端口

    private static Socket socket;

    /**
     * 初始化方法
     */
    public void init() throws Exception {

        IO.Options options = new IO.Options();
        options.transports = new String[]{"websocket"};
        options.timeout = 20000;              // 连接超时时间(ms)
        options.forceNew = true;
        options.query = "accessToken=" + UUID.randomUUID();
        socket = IO.socket("http://" + host +":" + port, options);

        socket.on(Socket.EVENT_CONNECT_ERROR, new Emitter.Listener() {
            @Override
            public void call(Object... args) {
                LOG.error("Socket.EVENT_CONNECT_ERROR");
            }
        }).on(Socket.EVENT_CONNECT_TIMEOUT, new Emitter.Listener() {
            @Override
            public void call(Object... args) {
                LOG.error("Socket.EVENT_CONNECT_TIMEOUT");
            }
        }).on(Socket.EVENT_DISCONNECT, new Emitter.Listener() {
            @Override
            public void call(Object... args) {
                LOG.warn("客户端断开连接啦。。。");
            }
        }).on(Socket.EVENT_RECONNECT_ATTEMPT, new Emitter.Listener() {
            @Override
            public void call(Object... args) {
                LOG.warn("客户端尝试重新连接到服务器");
            }
        });
        socket.connect();

    }

    /**
     * 停止服务（由Spring容器调用）
     */
    public void stop() {
        if (null != socket) {
            socket.close();
        }
    }

    public void setHost(String host) {
        this.host = host;
    }

    public void setPort(int port) {
        this.port = port;
    }

    /**
     * 推送流程运行状态
     *
     * @param workFlowId
     * @param message
     */
    public static void notify(String workFlowId, Message message) {
        Map<String, String> data = new HashMap<>();
        data.put("eventName", "notify");
        data.put("workFlowId", workFlowId);
        data.put("content", JSON.toJSONString(message));
        socket.emit("notify", data);
    }


    /**
     * 发送数据源同步结果
     * @param accessToken
     * @param content
     */
    public static void sendDataSyncResult(String accessToken, String content){
        Map<String, String> data = new HashMap<>();
        data.put("eventName", "dataSyncResult");
        data.put("accessToken", accessToken);
        data.put("content", content);
        socket.emit("notify", data);
    }

    public static boolean isConnected(){
        return socket.connected();
    }
}
