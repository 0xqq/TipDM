package com.tipdm.framework.dmserver.core.task.schedule;

import com.tipdm.framework.common.utils.DateKit;
import com.tipdm.framework.common.utils.PropertiesUtil;
import com.tipdm.framework.dmserver.core.task.listener.WorkFlowJobListener;
import com.tipdm.framework.dmserver.task.job.WorkFlowJobBean;
import com.tipdm.framework.dmserver.websocket.MessageServer;
import io.netty.util.internal.ConcurrentSet;
import org.apache.commons.lang3.ThreadUtils;
import org.quartz.*;
import org.quartz.impl.matchers.GroupMatcher;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

//import org.redisson.core.RMapCache;

/**
 * Created by TipDM on 2017/1/10.
 * E-mail:devp@tipdm.com
 */
//@Service("workFlowScheduler")
public class WorkFlowScheduler {

    private final static Logger logger = LoggerFactory.getLogger(WorkFlowScheduler.class);

    private static long timeout;

    private static Semaphore semaphore;

    public static final ThreadGroup jobCallbackGroup = new ThreadGroup("jobCallbackGroup");

    //队列线程池
//    private static LinkedBlockingQueue<Long> threadQueue;

    //初始化队列
    static {
        timeout = Long.valueOf(PropertiesUtil.getValue("sysconfig/quartz.properties", "quartz.timeout", "30")) * 60;
        int size = Integer.valueOf(PropertiesUtil.getValue("sysconfig/quartz.properties", "quartz.task.size", "30"));
        semaphore = new Semaphore(size);
        logger.info("workFlow schedule timeout: {}", timeout);
    }

    private Scheduler scheduler;

    public void setScheduler(Scheduler scheduler) {
        this.scheduler = scheduler;
    }

//    private WorkFlowWebSocketHandler workFlowWebSocketHandler = SpringUtils.getBean("workFlowWebSocketHandler", WorkFlowWebSocketHandler.class);


    /**
     * 运行流程
     *
     * @param flow
     * @return 流程ID
     */
    public String execute(WorkFlow flow) throws SchedulerException, IllegalAccessException {

        if (null == flow) {
            throw new SchedulerException("workFlow can not be null");
        }

        if(!MessageServer.isConnected()){
            throw new SchedulerException("推送服务未能连接，系统暂时无法处理您的请求");
        }

        try {
            //获取流程执行信号锁
            boolean acquire = semaphore.tryAcquire(1, TimeUnit.MINUTES);
            if(!acquire){
                throw new IllegalAccessException("服务器暂时无法处理您的请求，请稍后再试！");
            }
            String workFlowId = flow.getId();
            List<com.tipdm.framework.dmserver.core.task.model.Job> startNodes = flow.getStartNodes();

            if(startNodes == null || startNodes.size() == 0){
                semaphore.release();
                throw new SchedulerException("未能在流程中发现启动节点，请检查是否正确配置了输入源！");
            }
            shutdownWorkFlow(flow.getId());
            //监听jobdetail
            scheduler.getListenerManager().addJobListener(new WorkFlowJobListener(workFlowId), GroupMatcher.groupEquals(workFlowId));

            flow.updateState(WorkFlowState.RUNNING);
            ConcurrentSet<String> runningJobs = new ConcurrentSet<>();
            //启动一个线程监听流程
            JobCallback jobCallback = new JobCallback(flow, scheduler, semaphore);
            jobCallback.start();
            //获取所有的输入数据源节点和没有输入项的节点
            for (int i = 1; i <= startNodes.size(); i++) {
                com.tipdm.framework.dmserver.core.task.model.Job job = startNodes.get(i - 1);
                //从没有输入的节点开始执行流程
                TriggerKey triggerKey = TriggerKey.triggerKey(job.getJobId(), job.getJobGroup());
                Trigger trigger = newTrigger(triggerKey);
                JobKey jobKey = new JobKey(job.getJobId(), job.getJobGroup());
                JobDetail jobDetail = JobBuilder.newJob(WorkFlowJobBean.class).withIdentity(jobKey).build();

                jobDetail.getJobDataMap().put("workFlowId", flow.getId());
                jobDetail.getJobDataMap().put("jobId", job.getJobId());
                jobCallback.addJob(job.getJobId());
                Date date = scheduler.scheduleJob(jobDetail, trigger);

                logger.info("jobName: {} triggerKey: {} date: {}", jobDetail.getKey().getName(), trigger.getKey().getName(),
                        DateKit.convert2Str("yyyy-MM-dd HH:mm:ss", date));
            }
            return workFlowId;
        } catch (InterruptedException e) {
            throw new IllegalAccessException("服务器暂时无法处理您的请求，请稍后再试！");
        }
    }

    /**
     * 停止流程
     *
     * @param workFlowId 流程ID
     * @throws SchedulerException
     */
    public boolean shutdownWorkFlow(String workFlowId) throws SchedulerException {
        Collection collection = ThreadUtils.findThreadsByName(JobCallback.JOB_CALLBACK_PREFIX + workFlowId, WorkFlowScheduler.jobCallbackGroup);
        if(null != collection && collection.size() > 0) {
            JobCallback jobCallback = (JobCallback)collection.iterator().next();
            if (null != jobCallback) {
                jobCallback.shutdown();
            }
        }
        return true;
    }


    public static Trigger newTrigger(TriggerKey triggerKey) {
        Date startTime = DateBuilder.nextGivenSecondDate(null, 1);//延迟一秒钟执行
        logger.info("job will execute at: {}", DateKit.convert2Str("yyyy-MM-dd HH:mm:ss", startTime));
        SimpleTrigger trigger = TriggerBuilder.newTrigger()
                .withIdentity(triggerKey)
                .startAt(startTime)
                .withSchedule(
                        SimpleScheduleBuilder.simpleSchedule()
                                .withMisfireHandlingInstructionFireNow()//任务补偿策略：错过执行时间后立即执行
                                .withIntervalInSeconds(0)
                                .withRepeatCount(0))//不重复执行
                .build();
        return trigger;
    }
}
